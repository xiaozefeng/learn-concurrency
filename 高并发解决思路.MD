# 高并发解决思路
![](http://7xv4mv.com1.z0.glb.clouddn.com/2018-04-24-093234.png)
## 扩容
1. 垂直扩展(纵向扩展): 提高系统部件的能力
2. 水平扩展(横向扩展): 增加更多的系统成员的来实现

## 数据库扩容
1. 读操作扩展: memcache、redis、CDN等
2. 写操作扩展: Cassandra、Hbase等

## 缓存
![](http://7xv4mv.com1.z0.glb.clouddn.com/2018-04-24-025426.png)

### 缓存特征
1. 命中率: 命中数 / 元素总数
2. 最大元素(空间)
3. 清空策略: FIFO、LFU、LRU、过期时间、随机

### 影响缓存命中率的因素
1. 业务场景和业务需求
2. 缓存的设计 (粒度和策略)
3. 缓存容量和基础设施

### 缓存的分类和应用场景
#### 本地缓存
> 编程实现(成员变量、局部变量、静态变量、Guava Cache)

#### 分布式缓存
> Redis、Memcache

### 高并发场景下缓存常见问题
#### 缓存一致性
![](http://7xv4mv.com1.z0.glb.clouddn.com/2018-04-24-064109.png)
#### 缓存并发问题
> 缓存过期后，将尝试从数据库获取数据，但是在高并发场景下，有可能多个请求从数据获取数据，
对数据库造成极大的冲击，甚至造成雪崩现象.

#### 缓存穿透问题 
> 在高并发场景下，如果某一个key被并发的访问，没有被命中，出于对容错性的考虑，会尝试去从后端数据库去获取，
从而导致了大量的请求达到了数据库，而当该key对应的数据本身就是空的情况下，这就导致了数据库中执行了很多
不必要的查询操作，从而导致了巨大的冲击和压力.

`解决方案`:    
1. 缓存空对象，对查询结果为空的也进行缓存，如果是集合可以缓存空的集合；如果是空对象，可以使用字段标识，这种方式适合频繁更新的数据
2. 单独过滤处理, 对所有可能为空的数据进行统一的存放，并在请求前做拦截

#### 缓存的雪崩现象


## 消息队列
### 特征
1. 业务无关: 只做消息分发
2. FIFO: 先投递，先处理
3. 容灾: 节点的动态删减和消息持久化
4. 性能: 吞吐量提升，系统内部通信消息提高


### 为什么需要消息队列
1. 【生产】和【消费】的速度或稳定性等因素不一致

### 消息队列的好处
1. 业务解耦
2. 最终一致性
3. 广播
4. 错峰和流控

## 应用拆分
### 拆分原则
1. 业务优先
2. 循序渐进 (边拆分边测试)
3. 兼顾技术: 重构、分层
4. 可靠测试

### dubbo
### Spring Cloud 微服务 (拆分为微服务需要解决哪些问题?)
1. 客户端如何访问这些服务: api gateway
2. 每个服务之间是如何通信的: 同步调用使用rest或者rpc、异步通信使用消息队列
3. 如此多的服务如何实现: 服务发现
4. 服务挂了该怎么解决: 服务降级、服务熔断


## 应用限流
1. 计数器算法
2. 滑动窗口算法
3. 漏桶算法
4. 令牌桶算法 (guava有实现)

## 高可用的一些手段
- 任务调度系统分布式: elastic-job + zookeeper
- 主备切换: apache curator + zookeeper 分布式锁实现
- 监控报警机制
